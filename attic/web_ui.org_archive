#    -*- mode: org -*-


Archived entries from file /Users/Nelsonian/Projects/ii/apisnoop/webui/web_ui.org


* Tutorials
  :PROPERTIES:
  :ARCHIVE_TIME: 2018-10-18 Thu 16:34
  :ARCHIVE_FILE: ~/Projects/ii/apisnoop/webui/web_ui.org
  :ARCHIVE_OLPATH: Footnotes/Process
  :ARCHIVE_CATEGORY: web_ui
  :END:
   I am going through some simple tutorials for connecting react to redux to feathers.  It's a slightly longer process, but it's going to set me up better for maintaining apisnoop.  My assumption is that this is not a one-and-done thing.  We will be continually adding features to apisnoop and these features will become increasingly more complex. In addition, we'll be needing to adapt apisnoop for different scenarios. So I want to understand the stack for our webapp entirely.

I am coming in with good html and css knowledge for building personal projects.  What we are building is a production level app.  No matter how simple we make it, we will be pinging different sites, manipulating the data within those sites, and then displaying visualizations of our manipulations.  There isn't really a way to do this casually.  Especially if we want it to be stury and testable.  So I am biting off the sizable task of 'build a full-stack production-ready app by myself'.  I want to have all the tools I can to do this.

So I am going to make a v. simple fullstack app and then add in our own customizations until we get to the point where I can hear a task and know exactly how to realize it in this code.

* buildJsonHierarchy
  :PROPERTIES:
  :ARCHIVE_TIME: 2018-10-22 Mon 08:13
  :ARCHIVE_FILE: ~/apisnoop/webui/web_ui.org
  :ARCHIVE_OLPATH: Backend/Services/Sunburst/Hooks
  :ARCHIVE_CATEGORY: web_ui
  :END:

  The data coming into this hook looks like so:
  #+NAME: sunburst object structure
  #+BEGIN_SRC json :tangle no
    {starburst: {
      alpha: {
        settings {...},
        rbacauthorization {...},
        storage	{…},
        batch	{…},
        admissionregistration	{…},
        scheduling	{…},
        auditregistration	{…}
      },
      beta: {
        settings {...},
        rbacauthorization {...},
        storage	{…},
        batch	{…},
        admissionregistration	{…},
        scheduling	{…},
        auditregistration	{…}
      },
      stable: {
        settings {...},
        rbacauthorization {...},
        storage	{…},
        batch	{…},
        admissionregistration	{…},
        scheduling	{…},
        auditregistration	{…}
      }
    }
  #+END_SRC

  sample data from existing sunburst that works:
  #+NAME: What we want it to look like
  #+BEGIN_SRC json :tangle no
    {
      "tree": {
        "name": "root",
        "children": [
          {
            "name": "stable",
            "children": [
              {
                "name": "core",
                "children": [
                  {
                    "name": "get /api/",
                    "color": "category.core",
                    "url": "get /api/",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/",
                    "color": "category.core",
                    "url": "get /api/v1/",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/componentstatuses",
                    "color": "category.core",
                    "url": "get /api/v1/componentstatuses",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/configmaps",
                    "color": "category.core",
                    "url": "get /api/v1/configmaps",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "watch /api/v1/configmaps",
                    "color": "category.core",
                    "url": "watch /api/v1/configmaps",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/endpoints",
                    "color": "category.core",
                    "url": "get /api/v1/endpoints",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "watch /api/v1/endpoints",
                    "color": "category.core",
                    "url": "watch /api/v1/endpoints",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/limitranges",
                    "color": "category.core",
                    "url": "get /api/v1/limitranges",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "watch /api/v1/limitranges",
                    "color": "category.core",
                    "url": "watch /api/v1/limitranges",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/namespaces",
                    "color": "category.core",
                    "url": "get /api/v1/namespaces",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "post /api/v1/namespaces",
                    "color": "category.core",
                    "url": "post /api/v1/namespaces",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "watch /api/v1/namespaces",
                    "color": "category.core",
                    "url": "watch /api/v1/namespaces",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "delete /api/v1/namespaces/{namespace}/configmaps",
                    "color": "category.core",
                    "url": "delete /api/v1/namespaces/{namespace}/configmaps",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/namespaces/{namespace}/configmaps",
                    "color": "category.core",
                    "url": "get /api/v1/namespaces/{namespace}/configmaps",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "post /api/v1/namespaces/{namespace}/configmaps",
                    "color": "category.core",
                    "url": "post /api/v1/namespaces/{namespace}/configmaps",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "watch /api/v1/namespaces/{namespace}/configmaps",
                    "color": "category.core",
                    "url": "watch /api/v1/namespaces/{namespace}/configmaps",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "delete /api/v1/namespaces/{namespace}/configmaps/{name}",
                    "color": "category.core",
                    "url": "delete /api/v1/namespaces/{namespace}/configmaps/{name}",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/namespaces/{namespace}/configmaps/{name}",
                    "color": "category.core",
                    "url": "get /api/v1/namespaces/{namespace}/configmaps/{name}",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "put /api/v1/namespaces/{namespace}/configmaps/{name}",
                    "color": "category.core",
                    "url": "put /api/v1/namespaces/{namespace}/configmaps/{name}",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "delete /api/v1/namespaces/{namespace}/endpoints",
                    "color": "category.core",
                    "url": "delete /api/v1/namespaces/{namespace}/endpoints",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/namespaces/{namespace}/endpoints",
                    "color": "category.core",
                    "url": "get /api/v1/namespaces/{namespace}/endpoints",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "post /api/v1/namespaces/{namespace}/endpoints",
                    "color": "category.core",
                    "url": "post /api/v1/namespaces/{namespace}/endpoints",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "watch /api/v1/namespaces/{namespace}/endpoints",
                    "color": "category.core",
                    "url": "watch /api/v1/namespaces/{namespace}/endpoints",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "delete /api/v1/namespaces/{namespace}/endpoints/{name}",
                    "color": "category.core",
                    "url": "delete /api/v1/namespaces/{namespace}/endpoints/{name}",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/namespaces/{namespace}/endpoints/{name}",
                    "color": "category.core",
                    "url": "get /api/v1/namespaces/{namespace}/endpoints/{name}",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "put /api/v1/namespaces/{namespace}/endpoints/{name}",
                    "color": "category.core",
                    "url": "put /api/v1/namespaces/{namespace}/endpoints/{name}",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "delete /api/v1/namespaces/{namespace}/limitranges",
                    "color": "category.core",
                    "url": "delete /api/v1/namespaces/{namespace}/limitranges",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/namespaces/{namespace}/limitranges",
                    "color": "category.core",
                    "url": "get /api/v1/namespaces/{namespace}/limitranges",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "post /api/v1/namespaces/{namespace}/limitranges",
                    "color": "category.core",
                    "url": "post /api/v1/namespaces/{namespace}/limitranges",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  }
  #+END_SRC

  We have some code now, that is using our audits.data to build out a sunburst.  It looks like this. This was based off the original hierarchy, but now using our new data structure.
  #+NAME: buildJsonHierarchy
  #+BEGIN_SRC js
    // Use this hook to manipulate incoming or outgoing data.
    // For more information on hooks see: http://docs.feathersjs.com/api/hooks.html

    // eslint-disable-next-line no-unused-vars
    module.exports = function (options = {}) {
      return async context => {
        context.data.formatted = 'hi'
        return context;
      };

      function formatForSunburst (data) {
        var json = buildHierarchy(data.data)
        return json
      }


      function buildHierarchy(csv) {
        var root = createNode('root')
        var parentNode;
        var levelNode;
        var categoryNode;
        for (var i = 0; i < csv.length; i++) {
          var level = csv[i]['level']
          var category = csv[i]['category']
          var method_url = csv[i]['method + url']
          var size = +csv[i]['count'];
          if (isNaN(size)) { // e.g. if this is a header row
            continue;
          }

          var node = findChild(root, level)
          if (node == null) {
            node = createNode(level, {
              'color': 'level.' + level
            })
            root['children'].push(node)
          }
          parentNode = levelNode = node

          node = findChild(parentNode, category)
          if (node == null) {
            node = createNode(category,  {
              'color': 'category.' + category
            })
            parentNode['children'].push(node)
          }
          parentNode = categoryNode = node

          node = findChild(parentNode, method_url)
          if (node == null) {
            if (method_url === 'unused') {
              method_url = 'untested'
              var attrs = {'color': 'category.unused'}
              categoryNode.untested += size
              levelNode.untested += size
              root.untested += size
            } else {
              attrs = {'color': 'category.' + category}
              categoryNode.tested += size
              levelNode.tested += size
              root.tested += size
            }
            categoryNode.total += size
            levelNode.total += size
            root.total += size
            attrs.url = method_url
            node = createEndNode(method_url, attrs)
            parentNode['children'].push(node)
          }
          node['size'] = size
        }
        return root;
      }

      function findChild(parentNode, nodeName) {
        var children = parentNode.children;
        for (var k = 0; k < children.length; k++) {
          if (children[k]["name"] === nodeName) {
            return children[k];
          }
        }
        return null
      }

      function createNode(name, attrs) {
        var node = {
          "name": name,
          "children": [],
          'tested': 0,
          'untested': 0,
          'total': 0,
        };
        if (attrs) {
          node = Object.assign(node, attrs)
        }
        return node
      }

      function createEndNode(name, attrs) {
        var node = {
          "name": name,
        };
        if (attrs) {
          node = Object.assign(node, attrs)
        }
        return node
      }

    };

  #+END_SRC


* buildJsonHierarchy
  :PROPERTIES:
  :ARCHIVE_TIME: 2018-10-22 Mon 08:13
  :ARCHIVE_FILE: ~/apisnoop/webui/web_ui.org
  :ARCHIVE_OLPATH: Backend/Services/Sunburst/Hooks
  :ARCHIVE_CATEGORY: web_ui
  :END:

  The data coming into this hook looks like so:
  #+NAME: sunburst object structure
  #+BEGIN_SRC json :tangle no
    {starburst: {
      alpha: {
        settings {...},
        rbacauthorization {...},
        storage	{…},
        batch	{…},
        admissionregistration	{…},
        scheduling	{…},
        auditregistration	{…}
      },
      beta: {
        settings {...},
        rbacauthorization {...},
        storage	{…},
        batch	{…},
        admissionregistration	{…},
        scheduling	{…},
        auditregistration	{…}
      },
      stable: {
        settings {...},
        rbacauthorization {...},
        storage	{…},
        batch	{…},
        admissionregistration	{…},
        scheduling	{…},
        auditregistration	{…}
      }
    }
  #+END_SRC

  sample data from existing sunburst that works:
  #+NAME: What we want it to look like
  #+BEGIN_SRC json :tangle no
    {
      "tree": {
        "name": "root",
        "children": [
          {
            "name": "stable",
            "children": [
              {
                "name": "core",
                "children": [
                  {
                    "name": "get /api/",
                    "color": "category.core",
                    "url": "get /api/",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/",
                    "color": "category.core",
                    "url": "get /api/v1/",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/componentstatuses",
                    "color": "category.core",
                    "url": "get /api/v1/componentstatuses",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/configmaps",
                    "color": "category.core",
                    "url": "get /api/v1/configmaps",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "watch /api/v1/configmaps",
                    "color": "category.core",
                    "url": "watch /api/v1/configmaps",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/endpoints",
                    "color": "category.core",
                    "url": "get /api/v1/endpoints",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "watch /api/v1/endpoints",
                    "color": "category.core",
                    "url": "watch /api/v1/endpoints",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/limitranges",
                    "color": "category.core",
                    "url": "get /api/v1/limitranges",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "watch /api/v1/limitranges",
                    "color": "category.core",
                    "url": "watch /api/v1/limitranges",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/namespaces",
                    "color": "category.core",
                    "url": "get /api/v1/namespaces",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "post /api/v1/namespaces",
                    "color": "category.core",
                    "url": "post /api/v1/namespaces",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "watch /api/v1/namespaces",
                    "color": "category.core",
                    "url": "watch /api/v1/namespaces",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "delete /api/v1/namespaces/{namespace}/configmaps",
                    "color": "category.core",
                    "url": "delete /api/v1/namespaces/{namespace}/configmaps",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/namespaces/{namespace}/configmaps",
                    "color": "category.core",
                    "url": "get /api/v1/namespaces/{namespace}/configmaps",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "post /api/v1/namespaces/{namespace}/configmaps",
                    "color": "category.core",
                    "url": "post /api/v1/namespaces/{namespace}/configmaps",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "watch /api/v1/namespaces/{namespace}/configmaps",
                    "color": "category.core",
                    "url": "watch /api/v1/namespaces/{namespace}/configmaps",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "delete /api/v1/namespaces/{namespace}/configmaps/{name}",
                    "color": "category.core",
                    "url": "delete /api/v1/namespaces/{namespace}/configmaps/{name}",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/namespaces/{namespace}/configmaps/{name}",
                    "color": "category.core",
                    "url": "get /api/v1/namespaces/{namespace}/configmaps/{name}",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "put /api/v1/namespaces/{namespace}/configmaps/{name}",
                    "color": "category.core",
                    "url": "put /api/v1/namespaces/{namespace}/configmaps/{name}",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "delete /api/v1/namespaces/{namespace}/endpoints",
                    "color": "category.core",
                    "url": "delete /api/v1/namespaces/{namespace}/endpoints",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/namespaces/{namespace}/endpoints",
                    "color": "category.core",
                    "url": "get /api/v1/namespaces/{namespace}/endpoints",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "post /api/v1/namespaces/{namespace}/endpoints",
                    "color": "category.core",
                    "url": "post /api/v1/namespaces/{namespace}/endpoints",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "watch /api/v1/namespaces/{namespace}/endpoints",
                    "color": "category.core",
                    "url": "watch /api/v1/namespaces/{namespace}/endpoints",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "delete /api/v1/namespaces/{namespace}/endpoints/{name}",
                    "color": "category.core",
                    "url": "delete /api/v1/namespaces/{namespace}/endpoints/{name}",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/namespaces/{namespace}/endpoints/{name}",
                    "color": "category.core",
                    "url": "get /api/v1/namespaces/{namespace}/endpoints/{name}",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "put /api/v1/namespaces/{namespace}/endpoints/{name}",
                    "color": "category.core",
                    "url": "put /api/v1/namespaces/{namespace}/endpoints/{name}",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "delete /api/v1/namespaces/{namespace}/limitranges",
                    "color": "category.core",
                    "url": "delete /api/v1/namespaces/{namespace}/limitranges",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/namespaces/{namespace}/limitranges",
                    "color": "category.core",
                    "url": "get /api/v1/namespaces/{namespace}/limitranges",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "post /api/v1/namespaces/{namespace}/limitranges",
                    "color": "category.core",
                    "url": "post /api/v1/namespaces/{namespace}/limitranges",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  }
  #+END_SRC

  We have some code now, that is using our audits.data to build out a sunburst.  It looks like this. This was based off the original hierarchy, but now using our new data structure.
  #+NAME: buildJsonHierarchy
  #+BEGIN_SRC js
    // Use this hook to manipulate incoming or outgoing data.
    // For more information on hooks see: http://docs.feathersjs.com/api/hooks.html

    // eslint-disable-next-line no-unused-vars
    module.exports = function (options = {}) {
      return async context => {
        context.data.formatted = 'hi'
        return context;
      };

      function formatForSunburst (data) {
        var json = buildHierarchy(data.data)
        return json
      }


      function buildHierarchy(csv) {
        var root = createNode('root')
        var parentNode;
        var levelNode;
        var categoryNode;
        for (var i = 0; i < csv.length; i++) {
          var level = csv[i]['level']
          var category = csv[i]['category']
          var method_url = csv[i]['method + url']
          var size = +csv[i]['count'];
          if (isNaN(size)) { // e.g. if this is a header row
            continue;
          }

          var node = findChild(root, level)
          if (node == null) {
            node = createNode(level, {
              'color': 'level.' + level
            })
            root['children'].push(node)
          }
          parentNode = levelNode = node

          node = findChild(parentNode, category)
          if (node == null) {
            node = createNode(category,  {
              'color': 'category.' + category
            })
            parentNode['children'].push(node)
          }
          parentNode = categoryNode = node

          node = findChild(parentNode, method_url)
          if (node == null) {
            if (method_url === 'unused') {
              method_url = 'untested'
              var attrs = {'color': 'category.unused'}
              categoryNode.untested += size
              levelNode.untested += size
              root.untested += size
            } else {
              attrs = {'color': 'category.' + category}
              categoryNode.tested += size
              levelNode.tested += size
              root.tested += size
            }
            categoryNode.total += size
            levelNode.total += size
            root.total += size
            attrs.url = method_url
            node = createEndNode(method_url, attrs)
            parentNode['children'].push(node)
          }
          node['size'] = size
        }
        return root;
      }

      function findChild(parentNode, nodeName) {
        var children = parentNode.children;
        for (var k = 0; k < children.length; k++) {
          if (children[k]["name"] === nodeName) {
            return children[k];
          }
        }
        return null
      }

      function createNode(name, attrs) {
        var node = {
          "name": name,
          "children": [],
          'tested': 0,
          'untested': 0,
          'total': 0,
        };
        if (attrs) {
          node = Object.assign(node, attrs)
        }
        return node
      }

      function createEndNode(name, attrs) {
        var node = {
          "name": name,
        };
        if (attrs) {
          node = Object.assign(node, attrs)
        }
        return node
      }

    };

  #+END_SRC


* buildJsonHierarchy
  :PROPERTIES:
  :ARCHIVE_TIME: 2018-10-22 Mon 08:14
  :ARCHIVE_FILE: ~/apisnoop/webui/web_ui.org
  :ARCHIVE_OLPATH: Backend/Services/Sunburst/Hooks
  :ARCHIVE_CATEGORY: web_ui
  :END:

  The data coming into this hook looks like so:
  #+NAME: sunburst object structure
  #+BEGIN_SRC json :tangle no
    {starburst: {
      alpha: {
        settings {...},
        rbacauthorization {...},
        storage	{…},
        batch	{…},
        admissionregistration	{…},
        scheduling	{…},
        auditregistration	{…}
      },
      beta: {
        settings {...},
        rbacauthorization {...},
        storage	{…},
        batch	{…},
        admissionregistration	{…},
        scheduling	{…},
        auditregistration	{…}
      },
      stable: {
        settings {...},
        rbacauthorization {...},
        storage	{…},
        batch	{…},
        admissionregistration	{…},
        scheduling	{…},
        auditregistration	{…}
      }
    }
  #+END_SRC

  sample data from existing sunburst that works:
  #+NAME: What we want it to look like
  #+BEGIN_SRC json :tangle no
    {
      "tree": {
        "name": "root",
        "children": [
          {
            "name": "stable",
            "children": [
              {
                "name": "core",
                "children": [
                  {
                    "name": "get /api/",
                    "color": "category.core",
                    "url": "get /api/",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/",
                    "color": "category.core",
                    "url": "get /api/v1/",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/componentstatuses",
                    "color": "category.core",
                    "url": "get /api/v1/componentstatuses",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/configmaps",
                    "color": "category.core",
                    "url": "get /api/v1/configmaps",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "watch /api/v1/configmaps",
                    "color": "category.core",
                    "url": "watch /api/v1/configmaps",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/endpoints",
                    "color": "category.core",
                    "url": "get /api/v1/endpoints",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "watch /api/v1/endpoints",
                    "color": "category.core",
                    "url": "watch /api/v1/endpoints",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/limitranges",
                    "color": "category.core",
                    "url": "get /api/v1/limitranges",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "watch /api/v1/limitranges",
                    "color": "category.core",
                    "url": "watch /api/v1/limitranges",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/namespaces",
                    "color": "category.core",
                    "url": "get /api/v1/namespaces",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "post /api/v1/namespaces",
                    "color": "category.core",
                    "url": "post /api/v1/namespaces",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "watch /api/v1/namespaces",
                    "color": "category.core",
                    "url": "watch /api/v1/namespaces",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "delete /api/v1/namespaces/{namespace}/configmaps",
                    "color": "category.core",
                    "url": "delete /api/v1/namespaces/{namespace}/configmaps",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/namespaces/{namespace}/configmaps",
                    "color": "category.core",
                    "url": "get /api/v1/namespaces/{namespace}/configmaps",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "post /api/v1/namespaces/{namespace}/configmaps",
                    "color": "category.core",
                    "url": "post /api/v1/namespaces/{namespace}/configmaps",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "watch /api/v1/namespaces/{namespace}/configmaps",
                    "color": "category.core",
                    "url": "watch /api/v1/namespaces/{namespace}/configmaps",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "delete /api/v1/namespaces/{namespace}/configmaps/{name}",
                    "color": "category.core",
                    "url": "delete /api/v1/namespaces/{namespace}/configmaps/{name}",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/namespaces/{namespace}/configmaps/{name}",
                    "color": "category.core",
                    "url": "get /api/v1/namespaces/{namespace}/configmaps/{name}",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "put /api/v1/namespaces/{namespace}/configmaps/{name}",
                    "color": "category.core",
                    "url": "put /api/v1/namespaces/{namespace}/configmaps/{name}",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "delete /api/v1/namespaces/{namespace}/endpoints",
                    "color": "category.core",
                    "url": "delete /api/v1/namespaces/{namespace}/endpoints",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/namespaces/{namespace}/endpoints",
                    "color": "category.core",
                    "url": "get /api/v1/namespaces/{namespace}/endpoints",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "post /api/v1/namespaces/{namespace}/endpoints",
                    "color": "category.core",
                    "url": "post /api/v1/namespaces/{namespace}/endpoints",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "watch /api/v1/namespaces/{namespace}/endpoints",
                    "color": "category.core",
                    "url": "watch /api/v1/namespaces/{namespace}/endpoints",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "delete /api/v1/namespaces/{namespace}/endpoints/{name}",
                    "color": "category.core",
                    "url": "delete /api/v1/namespaces/{namespace}/endpoints/{name}",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/namespaces/{namespace}/endpoints/{name}",
                    "color": "category.core",
                    "url": "get /api/v1/namespaces/{namespace}/endpoints/{name}",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "put /api/v1/namespaces/{namespace}/endpoints/{name}",
                    "color": "category.core",
                    "url": "put /api/v1/namespaces/{namespace}/endpoints/{name}",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "delete /api/v1/namespaces/{namespace}/limitranges",
                    "color": "category.core",
                    "url": "delete /api/v1/namespaces/{namespace}/limitranges",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "get /api/v1/namespaces/{namespace}/limitranges",
                    "color": "category.core",
                    "url": "get /api/v1/namespaces/{namespace}/limitranges",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  },
                  {
                    "name": "post /api/v1/namespaces/{namespace}/limitranges",
                    "color": "category.core",
                    "url": "post /api/v1/namespaces/{namespace}/limitranges",
                    "size": 1,
                    "style": {
                      "fillOpacity": 1
                    }
                  }
  #+END_SRC

  We have some code now, that is using our audits.data to build out a sunburst.  It looks like this. This was based off the original hierarchy, but now using our new data structure.
  #+NAME: buildJsonHierarchy
  #+BEGIN_SRC js
    // Use this hook to manipulate incoming or outgoing data.
    // For more information on hooks see: http://docs.feathersjs.com/api/hooks.html

    // eslint-disable-next-line no-unused-vars
    module.exports = function (options = {}) {
      return async context => {
        context.data.formatted = 'hi'
        return context;
      };

      function formatForSunburst (data) {
        var json = buildHierarchy(data.data)
        return json
      }


      function buildHierarchy(csv) {
        var root = createNode('root')
        var parentNode;
        var levelNode;
        var categoryNode;
        for (var i = 0; i < csv.length; i++) {
          var level = csv[i]['level']
          var category = csv[i]['category']
          var method_url = csv[i]['method + url']
          var size = +csv[i]['count'];
          if (isNaN(size)) { // e.g. if this is a header row
            continue;
          }

          var node = findChild(root, level)
          if (node == null) {
            node = createNode(level, {
              'color': 'level.' + level
            })
            root['children'].push(node)
          }
          parentNode = levelNode = node

          node = findChild(parentNode, category)
          if (node == null) {
            node = createNode(category,  {
              'color': 'category.' + category
            })
            parentNode['children'].push(node)
          }
          parentNode = categoryNode = node

          node = findChild(parentNode, method_url)
          if (node == null) {
            if (method_url === 'unused') {
              method_url = 'untested'
              var attrs = {'color': 'category.unused'}
              categoryNode.untested += size
              levelNode.untested += size
              root.untested += size
            } else {
              attrs = {'color': 'category.' + category}
              categoryNode.tested += size
              levelNode.tested += size
              root.tested += size
            }
            categoryNode.total += size
            levelNode.total += size
            root.total += size
            attrs.url = method_url
            node = createEndNode(method_url, attrs)
            parentNode['children'].push(node)
          }
          node['size'] = size
        }
        return root;
      }

      function findChild(parentNode, nodeName) {
        var children = parentNode.children;
        for (var k = 0; k < children.length; k++) {
          if (children[k]["name"] === nodeName) {
            return children[k];
          }
        }
        return null
      }

      function createNode(name, attrs) {
        var node = {
          "name": name,
          "children": [],
          'tested': 0,
          'untested': 0,
          'total': 0,
        };
        if (attrs) {
          node = Object.assign(node, attrs)
        }
        return node
      }

      function createEndNode(name, attrs) {
        var node = {
          "name": name,
        };
        if (attrs) {
          node = Object.assign(node, attrs)
        }
        return node
      }

    };

  #+END_SRC

* DONE rearrange data so it starts with stable instead of alpha.  This will make current visualization be  oriented the same as existing vis.
  CLOSED: [2018-10-30 Tue 11:51]
  :PROPERTIES:
  :ARCHIVE_TIME: 2018-10-30 Tue 11:51
  :ARCHIVE_FILE: ~/Projects/ii/apisnoop/webui/web_ui.org
  :ARCHIVE_OLPATH: Tasks
  :ARCHIVE_CATEGORY: web_ui
  :ARCHIVE_TODO: DONE
  :END:

* The Original Reducer
  :PROPERTIES:
  :ARCHIVE_TIME: 2018-10-31 Wed 10:22
  :ARCHIVE_FILE: ~/Projects/ii/apisnoop/webui/web_ui.org
  :ARCHIVE_OLPATH: Client/Reducers/Releases Reducer
  :ARCHIVE_CATEGORY: web_ui
  :END:
  #+NAME: The Releases Reducer
  #+BEGIN_SRC js
    export default (state = defaultState, action = {}) => {
      switch (action.type) {
      case 'FETCH_RELEASE_NAMES_FULFILLED': {
        return {
          ...state,
          release_names: action.payload.data
        }
      }
      case 'FETCH_RELEASE_FULFILLED': {
        return {
          ...state,
          active_release: {name: action.payload.data[0].name, ...action.payload.data[0].data},
          loading: false
        }
      }
      case 'FETCH_RELEASES_FULFILLED': {
        var masterRelease = action.payload.data.find(data => {
          return data.name.toLowerCase().includes('master')
        })
        var selectedAgents = Object.keys(masterRelease.data.useragents).filter(key => {
          if (key.match(/e2e/)) {
            return key
          }
        })
        return {
          ...state,
          releases: action.payload.data,
          names: action.payload.data.map(data => {
            data = data.name
            return data
          }),
          main_release: masterRelease,
          selected_agents: selectedAgents,
          loading: false
        }
      }
      case 'NEW_MAIN_CHOSEN': {
        var newMain = state.releases.find(release => {
          return release.name === action.payload
        })
        var selectedAgents = Object.keys(newMain.data.useragents).filter(key => {
          if (key.match(/e2e/)) {
            return key
          }
        })
        return {
          ...state,
          main_release: newMain,
          selected_agents: selectedAgents
        }
      }
      default:
        return state;
      }
    }





  #+END_SRC

  #+RESULTS: The Releases Reducer

* SunburstChart
  :PROPERTIES:
  :header-args: :noweb yes :tangle ./client/src/components/sunburst-chart.js
  :ARCHIVE_TIME: 2018-10-31 Wed 16:46
  :ARCHIVE_FILE: ~/Projects/ii/apisnoop/webui/web_ui.org
  :ARCHIVE_OLPATH: Client/Components/Sunburst
  :ARCHIVE_CATEGORY: web_ui
  :END:
** Introduction
  We will be using react-vis' basic sunburst example as our guide for this, as it is the closest to what we want.  Our goal is to add in zoom animation and percentages in the center area, but for now let's just get this loading.

 Use code layout to see how it all fits, then check out each thing in specifics in the headers below.
** Import Modules
   The example uses extended discrete color range and label series, and both are referencing something with the files themselves.  I believe that we can just use labelseries since we are bringing in sunburst from react-vis, and the theme was just to help make the fill, which we can use with other colors instead.

  We'll bring in the flareData and Sample Data to try switching between the two.
   #+NAME: Import Modules
   #+BEGIN_SRC js :tangle no
     import React, { Component } from 'react';
     import { connect } from 'react-redux'
     import { Sunburst, LabelSeries } from 'react-vis'
     import * as _ from 'lodash'
   #+END_SRC
** Code Layout
   #+NAME: Code Layout
   #+BEGIN_SRC js
     <<License>>
     <<Import Modules>>

     <<Set Styling for Label>>
     <<Mapping Of Step Names To Colors>>

     class BasicSunburst extends Component {
         <<SB Setup Constructor>>
         <<SB Define componentDidMount>>
         <<Define getKeyPath>>
         <<Define updateData>>
         <<Define getDetails>>
         render() {
           const {clicked, data, finalValue, pathValue} = this.state
           const updateData = this.updateData
           const decoratedData = this.decoratedData
           const getKeyPath = this.getKeyPath
           return (
               <div className='basic-sunburst-wrapper'>
               <div className='basic-sunburst-example-path-name h2'>{pathValue}</div>
               <Sunburst
               className='basic-sunburst-example'
               hideRootNode
               <<SB onValueMouseOver>>
               <<SB onValueMouseOut>>
               onValueClick={()=> this.setState({clicked: !clicked})}
               style={{
                 stroke: '#ddd',
                 strokeOpacity: 0.3,
                 strokeWidth: '0.5'
               }}
               colorType="literal" // a style for react-vis. literal means 'literally the color palette given'
               getSize={d => d.size} // d refers to data, will need to be set differently for audit log
               getColor={d => d.color}  // same
               data={data} // Make sure you're actually providing data to the chart!
               height={900}
               width={1000}
               >
               <<SB Display Center finalValue>>
               </Sunburst>
               <<SB Click/Unclick Indicator>>
               </div>
           )
         }
     }

     function mapStateToProps (state) {
       return {
       }
     }

     export default connect(mapStateToProps)(BasicSunburst)
   #+END_SRC

   #+RESULTS: Code Layout
** Mapping Of Step Names To Colors
   #+NAME: Mapping Of Step Names To Colors
   #+BEGIN_SRC js :tangle no
     var colors = {
       'alpha': '#e6194b',
       'beta': '#0082c8',
       'stable': '#3cb44b',
       'unused': '#ffffff'
     }

     var categories = [
       "admissionregistration",
       "apiextensions",
       "apiregistration",
       "apis",
       "apps",
       "authentication",
       "authorization",
       "autoscaling",
       "batch",
       "certificates",
       "core",
       "events",
       "extensions",
       "logs",
       "networking",
       "policy",
       "rbacAuthorization",
       "scheduling",
       "settings",
       "storage",
       "version"
     ]

     var more_colors = [
       "#b71c1c", "#880E4F", "#4A148C", "#311B92", "#1A237E", "#0D47A1",
       "#01579B", "#006064", "#004D40", "#1B5E20", "#33691E", "#827717",
       "#F57F17", "#FF6F00", "#E65100", "#BF360C", "#f44336", "#E91E63",
       "#9C27B0", "#673AB7", "#3F51B5", "#2196F3", "#03A9F4", "#00BCD4",
       "#009688", "#4CAF50", "#8BC34A", "#CDDC39", "#FFEB3B", "#FFC107",
       "#FF9800", "#FF5722"
     ]

     for (var catidx = 0; catidx < categories.length; catidx++) {
       var category = categories[catidx]
       colors['category.' + category] = more_colors[(catidx * 3) % more_colors.length]
     }

   #+END_SRC

** License
   #+NAME: License
   #+BEGIN_SRC js :tangle no
     // Copyright (c) 2016 - 2017 Uber Technologies, Inc.
     //
     // Permission is hereby granted, free of charge, to any person obtaining a copy
     // of this software and associated documentation files (the "Software"), to deal
     // in the Software without restriction, including without limitation the rights
     // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     // copies of the Software, and to permit persons to whom the Software is
     // furnished to do so, subject to the following conditions:
     //
     // The above copyright notice and this permission notice shall be included in
     // all copies or substantial portions of the Software.
     //
     // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     // THE SOFTWARE.
   #+END_SRC
** Set Styling For Label
   This will be used for our LabelSeries later, defining how it should look.
   #+NAME: Set Styling for Label
   #+BEGIN_SRC js :tangle no
     const LABEL_STYLE = {
       fontSize: '20px',
       textAnchor: 'middle'
     }
   #+END_SRC
   It's written in the JSX style, so it's equal to a div having a 'style='font-size: 8px;', but in reactLand you can't just have the equal things be equal...we gotta do this camelCase stuff.
** Setup Constructor
      #+NAME: SB Setup Constructor
      #+BEGIN_SRC js :tangle no
        constructor(props) {
          super(props)
          this.state = {
            pathValue: false,
            data: {},
            finalValue: 'Sunburst',
            clicked: false
          }
          this.decoratedData = {}
          this.updateData = this.updateData.bind(this)
          this.getKeyPath = this.getKeyPath.bind(this)
        }


      #+END_SRC

      The constructor sets up the component-specific state; which helps us contain all the function and data within the component  itself.  So we set up the state for the component with the following values:
- pathValue :: When you hover over a node, shows the path you took to get to that node.  Will end up being the array created by getKeyPath joined together into a string.
- data :: the data given to us by our store.  Right now it is flareData, but it will one day be a specific build.
- finalValue :: the name of the node you are on, essentially.  For the path it took through the url's to get to this node.  So this could be our literal endpoints.
- clicked :: true/false on whether we've clicked to lock our current node path.

We have to do some kinda verbose binding of our functions.  The point of this is so we can have this function show multiple times throughout the page and not have the results leak out into other components, it prevents bugs and strange behavior, essentially.
** Define componentDidMount
   #+NAME: SB Define componentDidMount
   #+BEGIN_SRC js :tangle no
     componentDidMount() {
         this.decoratedData = this.updateData(this.props.sunburst, false)
         this.setState({
           data: this.decoratedData,
           finalValue: ''
         })
     }
   #+END_SRC

   We don't want to hard-code the state of our component based on props, because then if the props change, the component itself doesn't.  Instead, we mount it on the page, and then update the state based on the props given.  This ensures that the component will always appear properly.  So here we are saying, "When the graph appears, take the props given to us by our state (the flareData) and decorate it.  Then, set the data in our state to this new decorated data.  The sunburst component renders whatever is in this.state.data, and so it will render now the json from our store.

   This is a common pattern with react components.  Let the initial state be a fairly solid thing, that then gets set again by actions after its already been mounted.

** Define getKeyPath
     #+NAME: Define getKeyPath
     #+BEGIN_SRC js :tangle no
       /**
        ,* Recursively work backwards from highlighted node to find path of valid nodes
        ,* @param {Object} node - the current node being considered
        ,* @returns {Array} - an array of strings describing the key route to teh current node.
        ,*/

       getKeyPath (node) {
         if (!node.parent) {
           return ['root']
         }

         return [(node.data && node.data.name) || node.name].concat(
           this.getKeyPath(node.parent)
         )
       }
     #+END_SRC

     This tree map is tracing the path of nodes through the JSON tree, like tracing the url path of a singular webpage within a website.  This is the function that defines this path.

     IT does so recursively.  For each node it asks, 'do you have a parent?' if it doesn't we know it's root and we'll return 'root.'   If it does, we will return the node's name and its' data (or just its name if no data is available).  Then, we'll [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat][concatenate]]  this array to whatever array is returned when we apply the same function to this node's parent.  So we'll end up with an array of strings, where each one is chained as a parent to the one before.

     This is explained well in the code example too, so we keeping it.
** Define updateData
     #+NAME: Define updateData
     #+BEGIN_SRC js :tangle no
       updateData (data, keyPath, parent=false) {
         if (data.children) {
           data.children.map(child => this.updateData(child,  keyPath, data))
         }
         // add a fill to all the uncolored cells
         if (!data.color) {
           var color = colors[data.name]
           if (!color) {
             data.style = { fill: 'lightgray' }
           }
           data.style = { fill: color}
         }
         if (!keyPath) {
           return data
         }
         if (parent && keyPath.length > 1) {
           var lastTwoInPath = [keyPath[keyPath.length - 2], keyPath[keyPath.length - 1]]
           var isActive = (parent, child) => {
             var parentChild = [parent.name, child.name]
             var diff = _.difference(parentChild, lastTwoInPath)
             return diff.length === 0 || parent.length === 1
           }
           data.style = {
             ...data.style,
             fillOpacity: isActive(parent, data) ? 1 : 0.2
           }
           return data
         }
         return data
       }
      #+END_SRC
      #+RESULTS: Define updateData

===
keypath = {
  stable: true,
  rbacAuthorization: true
}

path = ['stable', 'rbacAuthorization']
===
       This takes care of when the graph is first loaded, and upon mouse hover events.  It essentially adds a fill color to each node if it's part of the path we current have our mouse on.
    It's another recursive one, applying the fill at the very bottom and moving up.
 from the sites definition:
    Recursivey modify data depending on whetehr or not each cell has been selected by the hover/hlighlight
    @param {Object} data - the current node being considered
    @param {Object|Boolean} keyPath - a map of keys that are in the highlight path
       //if this is false then all nodes are marked as selected.//
    @returns {Object} Updated tree structure

** Click/Unclick Indicator
   #+NAME: SB Click/Unclick Indicator
   #+BEGIN_SRC js :tangle no
       <div>
       {clicked ? 'click to unlock selection' : 'click to lock selection'}
     </div>
   #+END_SRC

   This checks the component's state, if click is true, then let them know you can unlock selection.  otherwise, let them know they can click to lock.

** onValueMouseOver
   #+NAME: SB onValueMouseOver
   #+BEGIN_SRC js :tangle no
     onValueMouseOver={(node, dom) => {
       if (clicked) {
         return
       }
       const path = getKeyPath(node).reverse()
       this.setState({
         finalValue: `${node.name}`,
         pathValue: path.join(' > '),
         data: updateData(decoratedData, path)
       })
     }}
   #+END_SRC

   This is a value that is part of the react-vis api.  From that doc, this is a function that accepts (arc node, domEvent) as arguments.  In other words, we'll know the exact node upon which the mouse is over, and all the values given from our browser about that node element.

   We know that getKeyPath returns an array of strings, each subsequent one being the parent of the node string prior.  So here we set the path to being that array reversed, so it goes from root to smallest child.

   pathAsMap, to be honest, I don't fully understand.  It's used to decorate the data, and the data colors up a cell based on each section of the map being true or false.  So It hink it's saying "if this cell is in the path, mark it as true, otherwise it be false".

   Then, we set the state with these values.  finalValue is going to be the last node string in our path and pathValue is going to be the full path outlined like so: 'root > child1 > child2 > lastChild'

   Everytime you set the state with a react Component the whole component rerenders.  We will have things later down that are meant to display the pathVAlue and finalValue...so since we are setting them in the state and rendering the component again it's going to continually update what these show.

** onValueMouseOut
#+NAME: SB onValueMouseOut
#+BEGIN_SRC js :tangle no
  onValueMouseOut={()=>
      clicked
      ? () => {} // an empty function, essentially 'do nothing'
      : this.setState({
        pathValue: false,
        finalValue: false,
        data: updateData(decoratedData, false)
      })
    }
#+END_SRC

This is like onValueMouseOver, but handling when we leave the chart.  Clicking locks the arc's position--and so, if it's clicked we do nothing...we keep all the coloring and info as it is as it's locked in place.

If clicked isn't set, and we've left the chart, then return everything back to nothing.  No finalVAlue, no path that we're on, and update the data so all cells are colored again.

** Display Center finalValue
   #+NAME: SB Display Center finalValue
   #+BEGIN_SRC js :tangle no
     {finalValue && (
         <LabelSeries
       data={[{x: 0, y: 0, label: finalValue, style: LABEL_STYLE}]}
         />
     )}
   #+END_SRC

   LabelSeries is another component given to us by react-vis.  The data will want to know where the label will be placed, what it should be labelling, and what it should look like.  We are saying 'put it right in the center: x0/y0 and display the final node we are highlighting.'

** Refactoring
   - i removed animation from the sunburst and it improved its performance quite a bit.  What animation was it trying to do?  Look at react-vis docs.

* DONE change color of default to be gray, and apply color only if tested.
  CLOSED: [2018-11-01 Thu 09:04]
  :PROPERTIES:
  :ARCHIVE_TIME: 2018-11-01 Thu 09:04
  :ARCHIVE_FILE: ~/Projects/ii/apisnoop/webui/web_ui.org
  :ARCHIVE_OLPATH: Tasks
  :ARCHIVE_CATEGORY: web_ui
  :ARCHIVE_TODO: DONE
  :END:

* Our Current Flow
  :PROPERTIES:
  :ARCHIVE_TIME: 2018-11-04 Sun 22:01
  :ARCHIVE_FILE: ~/Projects/ii/apisnoop/webui/web_ui.org
  :ARCHIVE_OLPATH: Architecture
  :ARCHIVE_CATEGORY: web_ui
  :END:
   I would like to document the current setup, to make sure I can reason about it.

  We will have a site listed anywhere, for now it's localhost so we'll call it LH.

  We want to know which commits(?) of kubernetes should have conformance tests made for them, this is handled in a config.yaml file in kubernetes test-infra folder on github.

 The log of their tests is found in the artifacts of the latest build of the test found in gcsweb.k8s.io.  We need to know the exact url to ping for gcs to return any proper info for us.


And so we grab the config info from github and parse its contents looking for commits that we are intersted in (like all gce-conformance commits).  Then, we take a look at the test_group_name for each commit and use that info to parse the config file again.  Each test group name has a GCS_Prefix, which gives us the url path we can ping with gcsweb.io

So let's say there's a commit called 'commmit1.2'.  This commit has a test_group_name of 'foo_test'.  That test_group has a prefix of '/jenkins/tests/log/foo_test'.  This means we can go to gcsweb.io/gcs/jenkins/tests/log/foo_test and get more information about this particular test group.

That information is a bit of an overload though.  It has folders for all the builds along with a text file that contains a number that is the latest build.  so in foo_test we'd see a bunch of folders named "100, 101, 102, 103" plus "latest-build.txt".  Clicking on latest-build.txt gives us something like: '103', which we know means we should look in folder 103 for all the relevant stuff.

The txt file, though just a number, isn't stored on gcsweb.io.  It's actually stored at 'storage.googleapis.com'.  So trying to grab gcsweb.io/$GCS_PREFIX/latest-build.txt will give us a redirect.  If we grab that number, following the path of that latest build folder leads us to a url of something like:
http://gcsweb.k8s.io/gcs/kubernetes-jenkins/logs/foo_test-1-12/187/artifacts/bootstrap-e2e-master/

there's also different bootstrap folders beyond master for many of these.

Then, inside //this// folder would be some audit-logs.  These logs are what we are REALLLY looking for, as they have the data we want to visualize.


This means, though, that when we start up the app we need to ping github and with the converted response from that ping gcsweb.k8s.io and with the response from that site ping gcsweb again but at a specific url, looking for a specific type of file and with the response of that get a big buffer of text that we try to convert into json so that we can feed it into our components.


I feel like this is a tremendous amount to put onto a webpage upon first loading, and that there's a number of errors that could come up.  How much of this can be done by our server so it's at the ready when the page loads up.

For example: I can't imagine the config.yaml file updates /aaaalll/ that much.  If we have something that is current to the latest day, or even yesterday, would that be okay?  And if that's okay, is there a way we could pull the yaml file and add it to our database so we'd have something like:
- ourserver.com/dashboards
- ourserver.com/test_groups
- ourserver.com/commits
and each of these we could ping instead to get the info we want?  Then we aren't doing real-time conversion of a blob into a string into yaml into json---it's just ready for us.

In the same way, is there anyway we can parse our own api and grab the audit logs we need, and have them converted into json for us to parse.  So the web page loads, pings our server, finds the audit logs, and renders them.....That might be redundancy though, since they //are// already available on a server at gcsweb.  It just takes us some loops to figure out where.

The question I have, ultimately, is how much should be handled by the client and how much should be pre-requested/filtered/converted by the server before the client latches on---and whether there's a simpler way to do what we're trying to do.


* Plan for Demo
  :PROPERTIES:
  :ARCHIVE_TIME: 2018-11-04 Sun 22:02
  :ARCHIVE_FILE: ~/Projects/ii/apisnoop/webui/web_ui.org
  :ARCHIVE_OLPATH: Footnotes
  :ARCHIVE_CATEGORY: web_ui
  :END:
- show our sunburst
- show a cloud of all tags.
- show a dropdown for user-agent
- if you chooose a tag, the user-agent dropdown reduces to just tests run by that tag.
- If you click on a sig tag, pull its general info from kubernetes/community/sigs.yaml
- when you hover over an endpoint, show a list of tests that also hit that endpoint. and nubmer of times that test hits that endpoint.

* Understand the config.yaml file and what it's pointing to.
  :PROPERTIES:
  :ARCHIVE_TIME: 2018-11-04 Sun 22:02
  :ARCHIVE_FILE: ~/Projects/ii/apisnoop/webui/web_ui.org
  :ARCHIVE_OLPATH: Footnotes
  :ARCHIVE_CATEGORY: web_ui
  :END:
** TestGrid
   Our testgrid is located at: https://k8s-testgrid.appspot.com/

https://github.com/kubernetes/test-infra/blob/master/testgrid/config.yaml#L3028
Dashboard Config for conformance-all: https://github.com/kubernetes/test-infra/blob/master/testgrid/config.yaml#L3231
Production instance of conformance-all: https://k8s-testgrid.appspot.com/conformance-all

GCE https://k8s-testgrid.appspot.com/conformance-all#GCE,%20master%20(dev)

JOBS for GCE 1.12-dev https://k8s-gubernator.appspot.com/builds/kubernetes-jenkins/logs/ci-kubernetes-gce-conformance-latest-1-12
Historical artifa8cts, including latest:
https://k8s-gubernator.appspot.com/builds/kubernetes-jenkins/logs/ci-kubernetes-gce-conformance-latest-1-12
The specific latest build:
https://k8s-gubernator.appspot.com/build/kubernetes-jenkins/logs/ci-kubernetes-gce-conformance-latest-1-12/168/
Grab SOMETHING from the artifact folder for this job:
http://gcsweb.k8s.io/gcs/kubernetes-jenkins/logs/ci-kubernetes-gce-conformance-latest-1-12/168/
The audit log: https://storage.googleapis.com/kubernetes-jenkins/logs/ci-kubernetes-gce-conformance-latest-1-12/168/artifacts/bootstrap-e2e-master/kube-apiserver-audit.log
** Navigating the config.yaml
   Starting at , here is how to relate the url view with the info on
   <<
*** [[file:config_yamls/config.yaml::dashboard_groups:][dashboard_groups:]]

   These top level dashboard groups are what populate the top level of [[https://k8s-testgrid.appspot.com][k8s-testgrid.appspot.com]]
**** [[file:config_yamls/config.yaml::dashboards:][dashboards:]]
***** [[file:config_yamls/config.yaml::test_groups:][test_groups:]]

*** Example [[file:config_yamls/config.yaml::-%20name:%20conformance-gce][For dashboard: conformance-gce]]
 if you were to look at
 dashboards.name['conformance-gce'].dashboard_tab, that ties to the summary tab you see at [[https://k8s-testgrid.appspot.com/conformance-gce][k8s-testgrid.appspot.com/conformance-gce]]
*** Test groups
     k8s
    Every testgroup name you find at:
   ~dashboards.name['conformance-gce'].dashboard_tab.name~
   has a section called 'test_group_name', and each test group name has its gcs_prefix (GCS standing for 'Google Cloud Services')

   For example, the test group name 'ci-kubernetes-gce-conformance-stable-1-12' has a gcs prefix of 'kubernetes-jenkins/logs/ci-kubernetes-gce-conformance-stable-1-12'.

   The json path for this testgroup gcs prefix would be:
   test_groups.name['ci-kubernetes-gce-conformance-stable-1-12'].gcs_prefix

   which takes you here: [[file:config_yamls/config.yaml::gcs_prefix:%20kubernetes-jenkins/logs/ci-kubernetes-gce-conformance-stable-1-12][gce-conformance-latest-1-12 gcs_prefix]]

   We could then...point that to a url where we'd grab the artifacts?
   like:
  http://gcsweb.k8s.io/gcs/$GCS_PREFIX

  we want to grab the latest text build, which is found at
  http://gcsweb.k8s.io/gcs/$GCS_PREFIX/latest-build.txt
   The goal now is to try to get as much done on the server, instead of trying to do it upon page requests in the client.  So what we would like is to have a server with an api that the client can ping that would give back the data needed based on the branch.  So I could do a request in the client for gce-conformance branch 1.12(dev), and that'd tie to some easy to reason about api path (/branches/1.12-dev), and this gives us the name of the latest build and the data taken from kube-servers api log.

So ultimately we want to be bringing down the gigs of data for the audit-logs and converted into something that can be rendered into a graph.

* Backend
  :PROPERTIES:
  :ARCHIVE_TIME: 2018-11-06 Tue 09:21
  :ARCHIVE_FILE: ~/apisnoop/webui/web_ui.org
  :ARCHIVE_CATEGORY: web_ui
  :END:
** Setting up our API Initially
**** Generating the Services
     We will be using the processed data provided by the audit-log review to generate an api path for us to traverse.  Each build will have its own data, which will include the tags in it, the agents in it, and a sunburst path.
** Services
   (**NOTE**: for each service, make sure paginate is turned off.  In the future I should do this automatically.)
*** Introduction

Services refer to the different paths of our api, and the various jobs and manipulation we do to the data being fed through these paths.  They act as gatekeeepers to our various db's, so we aren't doing a bunch of db queries from all over the code and potentially causing strange behavior and hard to track errors.  Throug these, we have a consistent and reliable way to ask for and give data to our server: talk to the relevant service and have them do the work for you.

We generate a service using feathers cli.  This creates a number of files for us and makes sure the service is known to the entire backend.  Which is to say that there will be a number of file changes made when we make a new service, but the files within this section only refer to the core code we are writing.
**** Service Definitions
   We have two services now.
 - Config :: Handles the initial setup (reading json files from disk and distributing the file to the proper Releases service, performing any cleanup as necessary).
 - Releases ::  the heart of our data, has all the info we need by release and we use this for our presentational components in the front end..
*** Config
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./backend/src/services/config/config.class.js
    :END:
   The config is run whenever the server starts up, and takes JSON files placed in ~data/processed-audits~ and generates paths from the data held within.

   We are in a midpoint now from the original style, where we created a single path with many nests, to a new FLAT style (that is generally more preferred, and more [[https://zen-of-python.info/][zen]]).  ~api/v1/endpoints~ is the beginning of this flat style.  Here, we generate new endpoints from all the different files, but each one has a release, method, and name.  Then, when we want to see only stuff for 1.12, we query our endpoint access for those with a release of 1.12 (instead of finding the 1.12 entry and navigating through its various nests to get the endpoints).
**** Overall Layout
     #+NAME: config.class.js layout
     #+BEGIN_SRC js
       /* eslint-disable no-unused-vars */
       const fs = require('fs')
       class Service {
         constructor (options) {
           this.options = options || {};
         }

         async setup (app, params) {
           populateReleases(app,'../../data/processed-logs')
         }
       }

       <<Define populateReleases>>

       module.exports = function (options) {
         return new Service(options);
       };

       module.exports.Service = Service;
    #+END_SRC

We only have a single method here, which is setup.  We don't want this to be an accessible path, we are just using it to run through commands when the server first starts up.  In this case, we run a command that looks in a directory for processed JSons and puts each file into its own entry in our releases api path.
**** Define populateReleases
     #+NAME: Define populateReleases
     #+BEGIN_SRC js :tangle no
       function populateReleases (app, dir)  {
         var processedAudits = fs.readdirSync(dir)
         for (var i = 0; i < processedAudits.length; i++) {
           var fileName = processedAudits[i]
           var releaseJson = fs.readFileSync(`${dir}/${fileName}`, 'utf-8')
           var releaseData = JSON.parse(releaseJson)
           addEntryToReleaseService(app, fileName, releaseData)
           addEntryToEndpointService(app, fileName, releaseData)
           addEntryToTestService(app, fileName, releaseData)
         }
       }

       // I think we will not need this soon.
       async function addEntryToReleaseService (app, fileName, releaseData) {
         var service = app.service('/api/v1/releases')
         var name = fileName.replace('.json', '')
         var existingEntry = await service.find({query:{name}})
         if (existingEntry.length === 0) {
           service.create({name: name, data: releaseData})
         } else {
           service.update(existingEntry[0]._id, {name: name, data: releaseData})
         }
       }

       async function addEntryToEndpointService (app, fileName, releaseData) {
         var service = app.service('/api/v1/endpoints')
         var release = fileName.replace('.json', '')
         var endpointNames = Object.keys(releaseData.endpoints)
         var tests = releaseData.tests
         for (var endpointName of endpointNames) {
           var endpointMethods = Object.keys(releaseData.endpoints[endpointName])

           for (var endpointMethod of endpointMethods) {
             var rawEndpoint = releaseData.endpoints[endpointName][endpointMethod]
             var endpoint = {
               name: endpointName,
               method: endpointMethod,
               release: release,
               level: rawEndpoint.level,
               test_tags: rawEndpoint.test_tags,
               tests: rawEndpoint.tests,
               description: rawEndpoint.desc,
               path: rawEndpoint.path,
               category: rawEndpoint.cat,
               isTested: rawEndpoint.counter > 0
             }
             // An endpoint is unique by name, release, method.
             var existingEntry = await service.find({
               query:{
                 name: endpoint.name,
                 method: endpoint.method,
                 release: endpoint.release
               }
             })
             if (existingEntry.length === 0) {
               await service.create(endpoint)
             } else {
               await service.update(existingEntry[0]._id, endpoint)
             }
           }
         }
       }

       async function addEntryToTestService (app, fileName, releaseData) {
         var service = app.service('/api/v1/tests')
         var release = fileName.replace('.json', '')
         var testNames = Object.keys(releaseData.test_sequences)
         for (var testName of testNames) {
           var testSequence = releaseData.test_sequences[testName]
           var test = {
             name: testName,
             sequence: testSequence,
             release: release
           }
           // An test is unique by testName and Release.
           var existingEntry = await service.find({
             query:{
               name: test.name,
               release: test.release
             }
           })
           if (existingEntry.length === 0) {
             await service.create(test)
           } else {
             await service.update(existingEntry[0]._id, test)
           }
         }
       }

     #+END_SRC

     This will read the file and send the data to our releases service, but releaes will reject it by default because some of the fiels in the data have periods and our database does not like that.  So we add a hook to Releases that takes this data given to it and changes it's peirods to underscores before trying to add it to the database.  We generated the hook using feathers/cli, setting it to be before any create or update action...meaning it manipualtes the file BEFORE it is added to the db through CREATE or UPDATE
*** Releases
    The file that handles this service is boilerplate feathers, so we will use this section to write and discuss the hooks used as part of the releases service.
**** cleanReleaseData
     :PROPERTIES:
     :header-args-dis: :noweb yes :tangle ./backend/src/hooks/clean-release-data.js
     :END:
    #+NAME clean-release-data.js
    #+BEGIN_SRC js
      const _ = require('lodash')

      module.exports = function (options = {}) {
        return async context => {
          var data = context.data.data
          data = cleanUp(data)
          context.data = {name: context.data.name, data: data}
          return context;
        }
      }

      function cleanUp (obj) {
        var cleanObj = {}
        for (key in obj) {
          if (_.isPlainObject(obj[key])) {
            cleanObj[key.replace(/\./g,'_')] = cleanUp(obj[key])
          } else {
            cleanObj[key.replace(/\./g,'_')] = obj[key]
          }
        }
        return cleanObj
      }
    #+END_SRC
