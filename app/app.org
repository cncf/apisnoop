#+TITLE: App.org
#+TODO: IDEA(i) TODO(t) NEXT(n) IN-PROGRESS(p) BLOCKED(b) | DONE(d) DONE-AND-SHARED(!)
#+PROPERTY: header-args :dir (file-name-directory buffer-file-name)
#+PROPERTY: header-args:js :results silent :noweb yes

* Architecture
  - create-react-app as beginning boilerplate
  - redux-bundler
  - react
  - tachyons
  - pull everything from jsons inside =/data=
* Index.js
  :PROPERTIES:
  :header-args: :tangle ./src/index.js
  :END:
 #+NAME: index.js
 #+BEGIN_SRC js
   import React from 'react'
   import { render } from 'react-dom'
   import './index.css'

   import { Provider } from 'redux-bundler-react'

   import App from './components/app'
   import createStore from './bundles'
   var store = createStore()

   document.title = 'APISnoop | ' // + store.getState().routing.release

   render(
       <Provider store={store}>
       <App />
       </Provider>,
     document.getElementById('root')
   )
 #+END_SRC
* Components
** App
    :PROPERTIES:
    :header-args: :tangle ./src/components/app.js
    :END:
    the initiatory component.  This is sort of the standard layout in which all other views are placed within.
    #+Name: App.js
    #+BEGIN_SRC js
      import React from 'react'
      import navHelper from 'internal-nav-helper'
      import { connect } from 'redux-bundler-react'

      import Header from './header'
      import Footer from './footer'
      import MainPage from '../pages/main-page'

      export default connect(
        () => {
          return (
              <div>
              <Header />
              <MainPage />
              <Footer />
              </div>
          )
        }
      )
    #+END_SRC

    #+Name: App.js Original
    #+BEGIN_EXAMPLE js
      import React from 'react'
      import navHelper from 'internal-nav-helper'
      import { connect } from 'redux-bundler-react'

      import Header from './header'
      import Footer from './footer'

      export default connect(
        'selectMasterRelease',
        'selectRouteInfo',
        'doUpdateUrl',
        'selectRoute',
        ({ masterRelease, routeInfo, doUpdateUrl, route }) => {
          const CurrentPage = route
          if (masterRelease && routeInfo.url === '/') {
            doUpdateUrl(`/${masterRelease.name}`)
          }
          return (
              <div onClick={navHelper(doUpdateUrl)}>
              <Header />
              <CurrentPage />
              <Footer />
              </div>
          )
        }
      )
    #+END_EXAMPLE
** Header
    :PROPERTIES:
    :header-args: :tangle ./src/components/header.js
    :END:
   #+NAME: Header
   #+BEGIN_SRC js
import React from 'react'

export default () => (
    <header className='flex flex-row pt2 pb2 pl4 pr4 h3_5 items-center justify-between bg-light-gray black shadow-3'>
      <div id='logo' className= 'flex flex-wrap items-center'>
      <img className='h2' src='./assets/apisnoop_logo_v1.png' alt='logo for apisnoop, a magnifying glass with a sunburst graph inside.' />
      <h1 className='ma0 f4 fw4 pl2 avenir'>APISnoop</h1>
      </div>
      <div id='source-code' className='flex items-center'>
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fillRule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/></svg>
        <a href='https://github.com/cncf/apisnoop' title='github repo for apisnoop' className='link f7 pl1'>Source Code</a>
      </div>
    </header>
)


   #+END_SRC
** Metadata
    :PROPERTIES:
    :header-args: :tangle ./src/components/metadata.js
    :END:

    The heading of the page, detailing the job result, the bucket it came from, and more.
    #+NAME: Metadata
    #+BEGIN_SRC js
      import React from 'react'
      import { connect } from 'redux-bundler-react'


      const Metadata = (props) => {
        const {
          metadata
        } = props
        return (
          <section id='metadata'>
            <h1>{metadata.version}</h1>
            <p>from job {metadata.job} in bucket {metadata.bucket}</p>
          </section>
        )
      }

      export default connect(
        'selectMetadata',
        Metadata
      )
    #+END_SRC
** Footer
    :PROPERTIES:
    :header-args: :tangle ./src/components/footer.js
    :END:
   #+NAME: Footer
   #+BEGIN_SRC js
     import React from 'react'

     export default () => (
         <footer className='w-100 flex flex-row-ns pt2 pb2 h3 pl4 pr4 items-center justify-between bg-black black shadow-3 white'>
         <div id='logo' className= 'flex flex-wrap items-center justify-center'>
         <a className='contain bg-cncf bg-center white h-100 w4 mr4' href='https://cncf.io' title='leads to external cncf homepage'>
         <span className='o-0'>cncf</span>
         </a>
         <a className='contain bg-packet bg-center h-100 w4 mr4' href='https://packet.net' title='leads to external packet homepage'>
         <span className='o-0'>packet</span>
         </a>
         <h1 className='ma0 f4 fw4 pl2 avenir'>APISnoop</h1>
         </div>
         <div id='source-code' className='flex items-center'>
         </div>
         </footer>
     )
   #+END_SRC
* Pages
** Main Page
  :PROPERTIES:
  :header-args: :tangle ./src/pages/main-page.js
  :END:
  #+NAME: Main Page
  #+BEGIN_SRC js
    import React from 'react'
    import { connect } from 'redux-bundler-react'

    // import FilterContainer from '../components/filter-container' # a regex filter for endpoints.
    import Metadata from '../components/metadata'
    // import UseragentSearchContainer from '../components/useragent-search-container'
    // import SunburstAndSummary from '../components/sunburst-and-summary'
    // import ActiveTestsList from '../components/active-tests-list'
    // import ActiveTestSequence from '../components/active-test-sequence'

    function MainPage () {
      return (
        <main id='main-splash' className='min-vh-80 pa4 ma4 flex flex-column'>
          <Metadata />
          <h1>HELLO YOU ARE DOING GOODLY</h1>
          {/*<FilterContainer />*/}
          {/* <UseragentSearchContainer /> */}
          {/* <SunburstAndSummary /> */}
          {/* <ActiveTestsList /> */}
          {/* <ActiveTestSequence /> */}
        </main>
      )
    }

    export default connect(
      MainPage
    )
    #+END_SRC

* Bundles
** Index
   :PROPERTIES:
   :header-args: :tangle ./src/bundles/index.js
   :END:
   This is the root bundler, that takes all the other individual ones and composes a single super bundle.
***  Import And Compose Bundle
    We import all the various bundles we make here.  The only module we need is redux-bundle's compose bundle function.
    #+NAME: bundle index
    #+BEGIN_SRC js
      import { composeBundles } from 'redux-bundler'

      import jobResultsMetadata from './job-results-metadata'
      import endpoints from './endpoints'
      import colours from './colours'
      import sunburst from './sunburst'


      export default composeBundles(
        colours,
        endpoints,
        jobResultsMetadata,
        sunburst
      )
    #+END_SRC

** Colours
   :PROPERTIES:
   :header-args: :tangle ./src/bundles/colours.js :noweb yes
   :END:

   The colors used for our app, mapped to our levels and categories.  Now we can always identify a level by its color, no matter if we are seeing the level in our sunburst chart or as a title/tag somewhere else in the page.

***  Layout
   #+NAME: Colours bundle
   #+BEGIN_SRC js
     export default {
       name: 'colours',
       <<Colours Reducer>>,
       <<selectLevelColours>>,
       <<selectCategoryColours>>
     }
   #+END_SRC
***  Tests Layout

    (This sets up a mock store, state to run our tests on later.  everything dealing with tests ends up within =src/bundles/colours.test.js but is distributed throughout this passage so that the tests can be next to the functions they are testing.)

    #+NAME: Colours Tests Setup
    #+BEGIN_SRC js :tangle ./src/bundles/colours.test.js
      import { Reducer, Selector } from 'redux-testkit'
      import {composeBundlesRaw} from 'redux-bundler'
      import colours from './colours.js'

      const store = composeBundlesRaw(colours)
      const state = store().getState()

      <<Colours Initial State>>

      describe('Colours Reducer', () => {
        <<Colours Reducer Test>>
      })

      describe('Colours Selectors', () => {
        <<selectLevelColours Test>>
        <<selectCategoryColours Test>>
      })
    #+END_SRC

***  Colours Reducer

    **Action -> ColourState**
   Receives any actions and, no matter its payload, returns the initial Colourstate.

    #+NAME: Colours Initial State
    #+BEGIN_SRC js :tangle no
      const initialState = {
        colours: {
          'alpha': 'rgba(230, 25, 75, 1)',
          'beta': 'rgba(0, 130, 200, 1)',
          'stable': 'rgba(60, 180, 75, 1)',
          'unused': 'rgba(255, 255, 255, 1)'
        },
        moreColours: [
          'rgba(183, 28, 28, 1)',
          'rgba(136, 14, 79, 1)',
          'rgba(74, 20, 140, 1)',
          'rgba(49, 27, 146, 1)',
          'rgba(26, 35, 126, 1)',
          'rgba(13, 71, 161, 1)',
          'rgba(1, 87, 155, 1)',
          'rgba(0, 96, 100, 1)',
          'rgba(0, 77, 64, 1)',
          'rgba(27, 94, 32, 1)',
          'rgba(51, 105, 30, 1)',
          'rgba(130, 119, 23, 1)',
          'rgba(245, 127, 23, 1)',
          'rgba(255, 111, 0, 1)',
          'rgba(230, 81, 0, 1)',
          'rgba(191, 54, 12, 1)',
          'rgba(244, 67, 54, 1)',
          'rgba(233, 30, 99, 1)',
          'rgba(156, 39, 176, 1)',
          'rgba(103, 58, 183, 1)',
          'rgba(63, 81, 181, 1)',
          'rgba(33, 150, 243, 1)',
          'rgba(3, 169, 244, 1)',
          'rgba(0, 188, 212, 1)',
          'rgba(0, 150, 136, 1)',
          'rgba(76, 175, 80, 1)',
          'rgba(139, 195, 74, 1)',
          'rgba(205, 220, 57, 1)',
          'rgba(255, 235, 59, 1)',
          'rgba(255, 193, 7, 1)',
          'rgba(255, 152, 0, 1)',
          'rgba(255, 87, 34, 1)'

        ],
        categories: [
          "admissionregistration",
          "apiextensions",
          "apiregistration",
          "apis",
          "apps",
          "authentication",
          "authorization",
          "autoscaling",
          "batch",
          "certificates",
          "core",
          "events",
          "extensions",
          "logs",
          "networking",
          "policy",
          "rbacAuthorization",
          "scheduling",
          "settings",
          "storage",
          "version",
          "auditregistration",
          "coordination"
        ]
      }
    #+END_SRC


    #+NAME: Colours Reducer Test
    #+BEGIN_SRC js :tangle no
      it('should have initial state', () => {
        expect(colours.getReducer()()).toEqual(initialState)
      })
      it('should not have unknown actions affect state', ()=> {
        Reducer(colours.getReducer())
        .expect({type: 'NOT_EXISTING'})
        .toReturnState(initialState)
      })
    #+END_SRC

    #+NAME: Colours Reducer
    #+BEGIN_SRC js :tangle no
       getReducer: () => {
         <<Colours Initial State>>
         return (state=initialState, action) => {
           return state
         }
       }
    #+END_SRC

***  selectLevelColours
    ◊ColourState -> ◊LevelColours
    Given the ColourState return the LevelColours from the Colourstate
    Colours is an object structured as {level_name: rgba code}

    #+NAME: selectLevelColours Test
    #+BEGIN_SRC js :tangle no
      it('should list all the level colours', () => {
        var result = {
          alpha: 'rgba(230, 25, 75, 1)',
          beta: 'rgba(0, 130, 200, 1)',
          stable: 'rgba(60, 180, 75, 1)',
          unused: 'rgba(255, 255, 255, 1)'
        }
        Selector(colours.selectLevelColours).expect(state).toReturn(result)
      })
    #+END_SRC

    #+NAME: selectLevelColours
    #+BEGIN_SRC js :tangle no
   selectLevelColours: (state) => state.colours.colours
    #+END_SRC

***  selectCategoryColours

    ◊ColourState -> ◊CategoryColours
    Given the state, return object mapping categories to their colours
    CategoryColours is an object structured as {category.name : rgbaColor}

    #+NAME: selectCategoryColours Test
    #+BEGIN_SRC js :tangle no
      it('should show categories mapped to colours', () => {
        var result = {
          'category.admissionregistration': 'rgba(183, 28, 28, 1)',
          'category.apiextensions': 'rgba(49, 27, 146, 1)',
          'category.apiregistration': 'rgba(1, 87, 155, 1)',
          'category.apis': 'rgba(27, 94, 32, 1)',
          'category.apps': 'rgba(245, 127, 23, 1)',
          'category.authentication': 'rgba(191, 54, 12, 1)',
          'category.authorization': 'rgba(156, 39, 176, 1)',
          'category.autoscaling': 'rgba(33, 150, 243, 1)',
          'category.batch': 'rgba(0, 150, 136, 1)',
          'category.certificates': 'rgba(205, 220, 57, 1)',
          'category.core': 'rgba(255, 152, 0, 1)',
          'category.events': 'rgba(136, 14, 79, 1)',
          'category.extensions': 'rgba(26, 35, 126, 1)',
          'category.logs': 'rgba(0, 96, 100, 1)',
          'category.networking': 'rgba(51, 105, 30, 1)',
          'category.policy': 'rgba(255, 111, 0, 1)',
          'category.rbacAuthorization': 'rgba(244, 67, 54, 1)',
          'category.scheduling': 'rgba(103, 58, 183, 1)',
          'category.settings': 'rgba(3, 169, 244, 1)',
          'category.storage': 'rgba(76, 175, 80, 1)',
          'category.version': 'rgba(255, 235, 59, 1)',
          'category.auditregistration': 'rgba(255, 87, 34, 1)',
          'category.coordination': 'rgba(74, 20, 140, 1)'
        }
        Selector(colours.selectCategoryColours).expect(state).toReturn(result)
      })
    #+END_SRC

    #+NAME: selectCategoryColours
    #+BEGIN_SRC js :tangle no
      selectCategoryColours: (state) => {
        var colours = {}
        for (var catidx = 0; catidx < state.colours.categories.length; catidx++) {
          var category = state.colours.categories[catidx]
          colours['category.' + category] = state.colours.moreColours[(catidx * 3) % state.colours.moreColours.length]
        }
        return colours
      }

    #+END_SRC

** Endpoints
  :PROPERTIES:
    :header-args: :tangle ./src/bundles/endpoints.js :noweb yes
    :END:
  The operatorId's and their methods from the job results
****  Layout
    #+NAME: Endpoints bundle
    #+BEGIN_SRC js
      import { createSelector } from 'redux-bundler'
      import { groupBy, mapValues, transform } from 'lodash'

      import endpoints from '../data/endpoints.json'

      export default {
        name: 'endpoints',
          <<Endpoints Reducer>>,
          <<selectEndpoints>>,
          <<selectEndpointsByLevelAndCategoryAndOperatorId>>
      }
    #+END_SRC
**** Endpoints Reducer
   #+NAME: Endpoints Reducer
   #+BEGIN_SRC js :tangle no
     getReducer: () => {
       const initialState = endpoints
       return (state=initialState, action) => {
         return state
       }
     }
   #+END_SRC
**** selectEndpoints
     **◊State => ◊Endpoints**
     selects all the endpoints from the global state
     #+NAME: selectEndpoints
     #+BEGIN_SRC js :tangle no
       selectEndpoints: (state) => state.endpoints
     #+END_SRC
**** selectEndpointsByLevelAndCategoryAndOperatorId
     **◊Endpoints -> ◊GroupedEndpoints**
     Given all endpoints, organize them in proper structure for our sunburst tree

     We want to have parent and children from all our endpoints, so we need to take the flattened structure and nest it.  Our current nesting (level, category, and OpId) can change if there's a better grouping that we find

    #+NAME: selectEndpointsByLevelAndCategoryAndOperatorId
    #+BEGIN_SRC js :tangle no
      selectEndpointsByLevelAndCategoryAndOperatorId: createSelector(
        'selectEndpoints',
        (endpoints) => {
          var endpointsWithOpIds = mapValues (endpoints, (value, key, endpoints) => {
            return {operatorId: key, ...value}
          })
          var endpointsByLevel = groupBy(endpointsWithOpIds, 'level')
          return mapValues(endpointsByLevel, endpointsInLevel => {
            var endpointsByCategory = groupBy(endpointsInLevel, 'category')
            return mapValues(endpointsByCategory, endpointsInCategory => {
              return endpointsInCategory.map (endpoint => {
                return {
                  ...endpoint,
                  size: 1
                }
              })
            })
          })
        }
      )

    #+END_SRC

   We could also do this by kind, but it seems each category contains a kind of =''=, and for some categories that's their only kind.  Not sure how successfully this would display in the sunburst.
** JobResultsMetadata
  :PROPERTIES:
    :header-args: :tangle ./src/bundles/job-results-metadata.js :noweb yes
    :END:

  Metadata from job results used to populate our header information

****  Layout
    #+NAME: JobResultsMetadata bundle
    #+BEGIN_SRC js
      import jobResultsMetadata from '../data/job-results-metadata.json'

      export default {
        name: 'jobResultsMetadata',
        <<JobResultsMetadata Reducer>>,
        <<selectMetadata>>
      }
    #+END_SRC
****  TODO Tests Layout
     color as an example to draw from.
     #+NAME: Colours Tests Setup
     #+BEGIN_SRC js :tangle no
       import { Reducer, Selector } from 'redux-testkit'
       import {composeBundlesRaw} from 'redux-bundler'
       import colours from './colours.js'

       const store = composeBundlesRaw(colours)
       const state = store().getState()

       <<Colours Initial State>>

       describe('Colours Reducer', () => {
         <<Colours Reducer Test>>
       })

       describe('Colours Selectors', () => {
         <<selectLevelColours Test>>
         <<selectCategoryColours Test>>
       })
     #+END_SRC

**** Reducer

     **Action -> JRMState**
    Receives any actions and, no matter its payload, returns the initial JRMState.
    JRMState is ◊JobResultsMetadata , and draws from our =data= folder


     #+NAME: JobResultsMetadata Reducer Test
     #+BEGIN_SRC js :tangle no
       it('should have initial state', () => {
         expect(colours.getReducer()()).toEqual(initialState)
       })
       it('should not have unknown actions affect state', ()=> {
         Reducer(colours.getReducer())
           .expect({type: 'NOT_EXISTING'})
           .toReturnState(initialState)
       })
     #+END_SRC

     #+NAME: JobResultsMetadata Reducer
     #+BEGIN_SRC js :tangle no
        getReducer: () => {
       const initialState = jobResultsMetadata
          return (state=initialState, action) => {
            return state
          }
        }
     #+END_SRC

**** selectMetadata
     **JRMState -> JRMState**
     selects entire output of the JRM State to be used in our components.


     #+NAME: selectMetadata
     #+BEGIN_SRC js :tangle no
    selectMetadata: (state) => state.jobResultsMetadata
    #+END_SRC
** Sunburst
  :PROPERTIES:
  :header-args: :tangle ./src/bundles/sunburst.js :noweb yes
  :END:
*** Imports and Layout

    #+NAME: sunburst bundle
    #+BEGIN_SRC js
      import { createSelector } from 'redux-bundler'
      import { map, sortBy } from 'lodash'
      import { fadeColour } from '../lib/utils'

      export default {
        name: 'sunburst',
        <<selectSunburst>>
      }

      <<Helper Functions>>
    #+END_SRC

*** selectSunburst
    We want to create a sunburst, that has a specific sorting (where beta appears in bottom left.)  We did th is as two selectors before, could we do it with just one now?

  **◊GroupedEndpoints => ◊SunburstTree**
  //Takes our Grouped Endpoints to return an object with specific parent child structure, that is ready for d3 viz.//

  #+NAME: selectSunburst
  #+BEGIN_SRC js :tangle no
    selectSunburst: createSelector(
      'selectEndpointsByLevelAndCategoryAndOperatorId',
      'selectLevelColours',
      'selectCategoryColours',
      'selectQueryObject',
      (endpointsByLevelAndCategoryAndOperatorId, levelColours, categoryColours, query) => {
        return {
          name: 'root',
          children: map(endpointsByLevelAndCategoryAndOperatorId, (endpointsByCategoryAndOperatorId, level) => {
            return {
              name: level,
              color: determineLevelColours(query, levelColours, level),
              children: map(endpointsByCategoryAndOperatorId, (endpointsByOperatorId, category) => {
                return {
                  name: category,
                  color: determineCategoryColours(query, categoryColours, category, level),
                  children: sortedEndpoints(endpointsByOperatorId, categoryColours, query)
                }
              })
            }
          })
        }
      }
    )
  #+END_SRC

*** Helper Functions
    #+NAME: Helper Functions
    #+BEGIN_SRC js :tangle no
      function determineLevelColours (query, colours, level) {
        if (query.level === undefined || query.level === level) {
          return colours[level]
        } else {
          return fadeColour(colours[level], '0.1')
        }
      }

      function determineCategoryColours (query, categoryColours, category, level) {
        if (query.level === undefined) {
          return categoryColours[`category.${category}`]
        } else if (query.level === level && query.category === category){
          return categoryColours[`category.${category}`]
        } else {
          return fadeColour(categoryColours[`category.${category}`], '0.1')
        }
      }

      function determineEndpointColour (endpoint, categoryColours, query) {
        var initialColor = determineInitialEndpointColour(endpoint, categoryColours)
        if (query.level === undefined) {
          return initialColor
        } else if (query.level === endpoint.level && query.category === endpoint.category && query.name === endpoint.operatorId) {
          return initialColor
        } else {
          return fadeColour(initialColor, '0.1')
        }
      }

      function determineInitialEndpointColour (endpoint, categoryColours) {
        if (endpoint.testHits > 0 && endpoint.conformanceHits > 0)  {
          return categoryColours[`category.${endpoint.category}`]
        } else  if( endpoint.testHits > 0 && endpoint.conformanceHits === 0) {
          var color = categoryColours[`category.${endpoint.category}`]
          var fadedColor = fadeColour(color, '0.2')
          return fadedColor
        } else {
          return 'rgba(244, 244, 244, 1)'
        }
      }

      function sortedEndpoints (endpoints, categoryColours, query) {
        var sortedEndpoints = sortBy(endpoints, [
          'kind',
          (endpoint) => endpoint.testHits > 0,
          (endpoint) => endpoint.conformanceHits > 0
        ])
        return sortedEndpoints.map(endpoint => {
          return {
            name: endpoint.operatorId,
            kind: endpoint.kind,
            size: endpoint.size,
            color: determineEndpointColour(endpoint, categoryColours, query)
          }
        })
      }

    #+END_SRC
* Lib
** Utils
   :PROPERTIES:
   :header-args: :tangle ./src/lib/utils.js
   :END:
   #+NAME: Utils
   #+BEGIN_SRC js
     import {
       filter,
       isUndefined,
       size,
       words,
       pickBy } from 'lodash'

     export function calculateCoverage (endpoints) {
       var total = size(endpoints)
       var tested = size(filter(endpoints, ['isTested', true]))
       var percentage = (total, tested) => {
         if (!tested && !total) return 'No Endpoints'
         var percentageNumber = (100 * tested /total).toPrecision(3)
         return `${percentageNumber}%`
       }
       return {
         tested,
         total,
         percentage: percentage(total, tested),
         ratio: `${tested}/${total}`
       }
     }

     export function fadeColour (rgba, desiredOpacity) {
       var rgbaParts = words(rgba, /[^,|^(|^)]+/g)
       rgbaParts.pop()
       rgbaParts.push(desiredOpacity)
       var newRgbaString = rgbaParts.join(',')
       var newRgba = newRgbaString.replace(/,/,'(') + ')'
       return newRgba
     }

     export function propertiesWithValue (obj) {
       return pickBy(obj, (val) => !isUndefined(val))
     }


   #+END_SRC
* Data Definitions
** ColourState (<<<◊ColourState>>>)

   Colourstate is an Object, consisting of colours, moreColours, and categories.
   It is used to set the colours of the various levels, categories, and endpoints throughout the site.

     #+NAME: ColourState Example
     #+BEGIN_Example
       const initialState = {
         colours: {
           'alpha': 'rgba(230, 25, 75, 1)',
           'beta': 'rgba(0, 130, 200, 1)',
           'stable': 'rgba(60, 180, 75, 1)',
           'unused': 'rgba(255, 255, 255, 1)'
         },
         moreColours: [
           'rgba(183, 28, 28, 1)',
           'rgba(136, 14, 79, 1)',
           'rgba(74, 20, 140, 1)',
           'rgba(49, 27, 146, 1)',
           'rgba(26, 35, 126, 1)',
           'rgba(13, 71, 161, 1)',
           'rgba(1, 87, 155, 1)',
           'rgba(0, 96, 100, 1)',
           'rgba(0, 77, 64, 1)',
           'rgba(27, 94, 32, 1)',
           'rgba(51, 105, 30, 1)',
           'rgba(130, 119, 23, 1)',
           'rgba(245, 127, 23, 1)',
           'rgba(255, 111, 0, 1)',
           'rgba(230, 81, 0, 1)',
           'rgba(191, 54, 12, 1)',
           'rgba(244, 67, 54, 1)',
           'rgba(233, 30, 99, 1)',
           'rgba(156, 39, 176, 1)',
           'rgba(103, 58, 183, 1)',
           'rgba(63, 81, 181, 1)',
           'rgba(33, 150, 243, 1)',
           'rgba(3, 169, 244, 1)',
           'rgba(0, 188, 212, 1)',
           'rgba(0, 150, 136, 1)',
           'rgba(76, 175, 80, 1)',
           'rgba(139, 195, 74, 1)',
           'rgba(205, 220, 57, 1)',
           'rgba(255, 235, 59, 1)',
           'rgba(255, 193, 7, 1)',
           'rgba(255, 152, 0, 1)',
           'rgba(255, 87, 34, 1)'

         ],
         categories: [
           "admissionregistration",
           "apiextensions",
           "apiregistration",
           "apis",
           "apps",
           "authentication",
           "authorization",
           "autoscaling",
           "batch",
           "certificates",
           "core",
           "events",
           "extensions",
           "logs",
           "networking",
           "policy",
           "rbacAuthorization",
           "scheduling",
           "settings",
           "storage",
           "version",
           "auditregistration",
           "coordination"
         ]
       }
     #+END_EXAMPLE
** CategoryColours (<<<◊CategoryColours>>>)
   CategoryColours is an object, holding all categories mapped to moreColours from our ColourState

   #+NAME: CategoryColours Example
   #+BEGIN_SRC js
     {
       'category.admissionregistration': 'rgba(183, 28, 28, 1)',
       'category.apiextensions': 'rgba(49, 27, 146, 1)',
       'category.apiregistration': 'rgba(1, 87, 155, 1)',
       'category.apis': 'rgba(27, 94, 32, 1)',
       'category.apps': 'rgba(245, 127, 23, 1)',
       'category.authentication': 'rgba(191, 54, 12, 1)',
       'category.authorization': 'rgba(156, 39, 176, 1)',
       'category.autoscaling': 'rgba(33, 150, 243, 1)',
       'category.batch': 'rgba(0, 150, 136, 1)',
       'category.certificates': 'rgba(205, 220, 57, 1)',
       'category.core': 'rgba(255, 152, 0, 1)',
       'category.events': 'rgba(136, 14, 79, 1)',
       'category.extensions': 'rgba(26, 35, 126, 1)',
       'category.logs': 'rgba(0, 96, 100, 1)',
       'category.networking': 'rgba(51, 105, 30, 1)',
       'category.policy': 'rgba(255, 111, 0, 1)',
       'category.rbacAuthorization': 'rgba(244, 67, 54, 1)',
       'category.scheduling': 'rgba(103, 58, 183, 1)',
       'category.settings': 'rgba(3, 169, 244, 1)',
       'category.storage': 'rgba(76, 175, 80, 1)',
       'category.version': 'rgba(255, 235, 59, 1)',
       'category.auditregistration': 'rgba(255, 87, 34, 1)',
       'category.coordination': 'rgba(74, 20, 140, 1)'
     }
   #+END_SRC
** Endpoints (<<<◊Endpoints>>>)
 Endpoints is an array of Objects, with each key an OperationID.  They are the endpoints within the paths hit in our audit log

 Here is a single endpoint, so it's first group is OpID, which would be unique.
 #+NAME: Endpoints Definition Sample
 #+BEGIN_SRC json
   "getCodeVersion": {
     "category": "version",
     "kind": "",
     "group": "",
     "description": "get the code version",
     "conformanceHits": 0,
     "level": "stable",
     "isDeprecated": false,
     "hits": 0,
     "testHits": 0,
     "version": "",
     "path": "/version/"
   }

 #+END_SRC
** GroupedEndpoints (<<<◊GroupedEndpoints)
   An Object, derived from ◊Endpoints, where they are grouped by arbitrary keys.  In the current case, these keys are Level, then category, the operatorId.  This sets us up to turn it into a sunburst more easily.

   #+NAME: GroupedEndpoints Definition Example
   #+BEGIN_SRC json
     {
       alpha:{
         ...list of categories, with each containing array of endpointObjects...
       },
       beta: {
         ...list of categories, with each containing array of endpointObjects...
       },
       stable: {
         core: [],
         api: [],
         apps: [
           {
             category: "apis",
             conformanceHits: 196,
             description: "something",
             group: '',
             hits: 2828,
             isDeprecated: false,
             kind: "",
             level: "stable",
             operatorId: "getAPIVersions",
             path: "apis/",
             size: 1,
             testHits: 920,
             version: ""
           },
           {
             ...diff endpoint, same structure as above...
           }
         ]
     }

   #+END_SRC

** JobResultsMetadata (<<<◊JobResultsMetadata>>>)
   JobResultsMetadata is a JSON Object.
   Interpretation: metadata used to populate the header of our page, with information on the job release we are looking at.
   #+NAME: JobResultsMetadata Definition Example
   #+BEGIN_SRC json :tangle ./src/data/job-results-metadata.json
     {
       "job": "36092",
       "bucket": "ci-kubernetes-e2e-gci-gce",
       "version": "v1.15.0-alpha.0.1493",
       "job-version": "v1.15.0-alpha.0.1493+1cb550295a9314",
       "master_os_image": "cos-beta-73-11647-64-0",
       "infra-commit": "279855f78",
       "node_os_image": "cos-beta-73-11647-64-0",
       "pod": "8fa53d0a-4f5a-11e9-8a35-0a580a6c1338",
       "passed": true,
       "result": "SUCCESS",
       "timestamp": 1553561320
     }
   #+END_SRC

   We can test it is valid json with =jq=
   #+BEGIN_SRC shell :results output
  cat ./data/job-results-metadata.json | jq .
   #+END_SRC

   #+RESULTS:
   #+begin_example
   {
     "job": "36092",
     "bucket": "ci-kubernetes-e2e-gci-gce",
     "version": "v1.15.0-alpha.0.1493",
     "job-version": "v1.15.0-alpha.0.1493+1cb550295a9314",
     "master_os_image": "cos-beta-73-11647-64-0",
     "infra-commit": "279855f78",
     "node_os_image": "cos-beta-73-11647-64-0",
     "pod": "8fa53d0a-4f5a-11e9-8a35-0a580a6c1338",
     "passed": true,
     "result": "SUCCESS",
     "timestamp": 1553561320
   }
   #+end_example
** LevelColours (<<<◊LevelColours>>>)
   LevelColours is an Object.
   It is the base colours attached to the four levels of our sunburst: Alpha, Beta, Stable, and Unused.
   #+NAME: LevelColours Example
   #+BEGIN_EXAMPLE js
     {
       alpha: 'rgba(230, 25, 75, 1)',
       beta: 'rgba(0, 130, 200, 1)',
       stable: 'rgba(60, 180, 75, 1)',
       unused: 'rgba(255, 255, 255, 1)'
     }
   #+END_EXAMPLE
** SunburstTree(<<<◊SunburstTree>>>)
   An Object built for the react-vis/d3 sunburst graph.  It requires a root that contains children, witch each children containing children, all the way to the end.

   In this case we have root>level>category>operatorId.

   #+NAME: SunburstTree Example
   #+BEGIN_SRC json
     {
       name: "root",
       children: [
         {
           name: "level",
           color: rgba color,
           children: [
             {
               name: "core",
               color: rgba color,
               children: [
                 {
                   name: operatorId,
                   size: 1,
                   testHits: 3,
                   conformanceTestHits: 2,
                   hits: 10,
                   color: rgba color
                 }
               ]
             }
           ]
         }
       ]
     }
   #+END_SRC

   We are reducing it down to the bare min info for endpoint.  If they hover over an endpo;int and wanna see more deets like group, version, kind then we can reference that from the ◊Endpoints already in the store.   This only contains info necessary to make the sunburst render correctly.

* Footnotes
** Endpoints...
   :PROPERTIES:
   :header-args: :dir ../..
   :END:
*** Exploration
**** overall
      If we base it off swagger.json, what does that look like?
      #+BEGIN_SRC  shell
     cat swagger.json | jq '. | keys'
      #+END_SRC

      #+RESULTS:
      | [                   |
      | definitions         |
      | info                |
      | paths               |
      | security            |
      | securityDefinitions |
      | swagger             |
      | ]                   |
**** Irrelevant sections
     Still useful in general, but not for our app
     #+NAME: swagger.info
      #+BEGIN_SRC  shell
     cat swagger.json | jq '.info'
      #+END_SRC

      #+RESULTS: swagger.info
      | {       |            |
      | title   | Kubernetes |
      | version | v1.15.0    |
      | }       |            |

     #+NAME: swagger.security
      #+BEGIN_SRC  shell
     cat swagger.json | jq '.security'
      #+END_SRC
      #+RESULTS: swagger.security
      | [           |    |
      | {           |    |
      | BearerToken | [] |
      | }           |    |
      | ]           |    |

     #+NAME: swagger.securityDefinitions
      #+BEGIN_SRC  shell
     cat swagger.json | jq '.securityDefinitions'
      #+END_SRC
      #+RESULTS: swagger.securityDefinitions

     #+NAME: swagger.swagger
      #+BEGIN_SRC  shell
     cat swagger.json | jq '.swagger'
      #+END_SRC
      #+RESULTS: swagger.swagger
      : 2.0

      here is a sample definition
     #+NAME: swagger.definitions
      #+BEGIN_SRC  shell
     cat swagger.json | jq '.definitions["io.k8s.api.apps.v1.ControllerRevisionList"] | keys'
      #+END_SRC

      #+RESULTS: swagger.definitions
      | [                               |
      | description                     |
      | properties                      |
      | required                        |
      | type                            |
      | x-kubernetes-group-version-kind |
      | ]                               |
**** Relevant Section: Paths
     #+NAME: Example Path
     #+BEGIN_SRC shell
      cat swagger.json | jq \
        '.paths["/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}"] | keys'
    #+END_SRC

    #+RESULTS: Example Path
    | [          |
    | delete     |
    | get        |
    | parameters |
    | patch      |
    | put        |
    | ]          |

    So here is a path, that has four methods/verbs, along with the parameters.

    And the operation id for each verb
    #+NAME: Operation ID's for each verb
    #+BEGIN_SRC shell :results output
      cat swagger.json | jq \
        '.paths["/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}"]["delete"]["operationId"]'
      cat swagger.json | jq \
        '.paths["/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}"]["get"]["operationId"]'
      cat swagger.json | jq \
        '.paths["/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}"]["patch"]["operationId"]'
      cat swagger.json | jq \
        '.paths["/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}"]["put"]["operationId"]'

    #+END_SRC

    #+RESULTS: Operation ID's for each verb
    : "deleteNetworkingV1NamespacedNetworkPolicy"
    : "readNetworkingV1NamespacedNetworkPolicy"
    : "patchNetworkingV1NamespacedNetworkPolicy"
    : "replaceNetworkingV1NamespacedNetworkPolicy"

    And within one of these, there isn't a section for "methods", but each one does have parameters.

    #+NAME: look at a single verb
    #+BEGIN_SRC shell :results output
      cat swagger.json | jq \
        '.paths["/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}"]["delete"]'
    #+END_SRC

    #+RESULTS: look at a single verb
    #+begin_example
    {
      "consumes": [
        "*/*"
      ],
      "description": "delete a NetworkPolicy",
      "operationId": "deleteNetworkingV1NamespacedNetworkPolicy",
      "parameters": [
        {
          "in": "body",
          "name": "body",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
          }
        },
        {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "in": "query",
          "name": "dryRun",
          "type": "string",
          "uniqueItems": true
        },
        {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "in": "query",
          "name": "gracePeriodSeconds",
          "type": "integer",
          "uniqueItems": true
        },
        {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "in": "query",
          "name": "orphanDependents",
          "type": "boolean",
          "uniqueItems": true
        },
        {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "in": "query",
          "name": "propagationPolicy",
          "type": "string",
          "uniqueItems": true
        }
      ],
      "produces": [
        "application/json",
        "application/yaml",
        "application/vnd.kubernetes.protobuf"
      ],
      "responses": {
        "200": {
          "description": "OK",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "202": {
          "description": "Accepted",
          "schema": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
          }
        },
        "401": {
          "description": "Unauthorized"
        }
      },
      "schemes": [
        "https"
      ],
      "tags": [
        "networking_v1"
      ],
      "x-kubernetes-action": "delete",
      "x-kubernetes-group-version-kind": {
        "group": "networking.k8s.io",
        "kind": "NetworkPolicy",
        "version": "v1"
      }
    }
    #+end_example

    Our current mode is to look at the opId and then the method's within.  And each opId has a path.  I assume this is the path we are taking.  What are the paramters related to?  And where are we getting the additional methods?

*** Initial Definition

I think the basic endpoint, without redundant info, could be:
#+NAME: Endpoint Definition
#+BEGIN_SRC json
  {
    "operationId": '',
    "path": '',
    "level": '',
    "category": '',
    "group": '',
    "version": '',
    "kind": '',
    "methods": [
      "get": {
        isTested: boolean,
        isConformance: boolean,
      },
      "watch": {
        isTested: boolean,
        isConformance: boolean,
      }
    ]
  }

#+END_SRC

The test tags and tests and such aren't needed, as they are in their own path.  When you hover over the method of an opId, then that becomes the  "activeOp" and we select the tests whose list of keys contain this opID[method].

we make the tested booleans more specific, as these determine the color in the sunburst and it's easy to just have it checked on render whether something is true or false, rather than determining if true on render.

We are't using counters yet, and there's so many different counters...that I'd rather not include them here (counter for hit by a test, a test tag, a user-agent, etc.)

IF we are filtering on zoom, then the zoom will have:
- level
- category
- opId
- method

you don't wnat to zoom all the way to method, though, cos you just get a big donut.  you wanna freeze the method, but zoom into opId.  So we can keep our basic filter and then just say if "zoom.method !== null then freeze sunburst" and freeze just disables the mouseOver/mouseAway options.

What does a useragent filter look like?
we'd have a list of opId methods that are hit by that user-agent  so it'd be nested.
So let's assume we could have something like this

#+NAME: endpointA
#+BEGIN_SRC json
  {
    "operationId": 'readFoo',
    "path": 'foo/',
    "level": 'stable',
    "category": 'core',
    "group": 'foos',
    "version": 'foo1',
    "kind": 'foothings',
    "methods": [
      "get": {
        isTested: true,
        isConformance: true,
      },
      "watch": {
        isTested: false,
        isConformance: false,
      }
    ]
  }
#+END_SRC

And our list of endpoints hit by user-agent as
#+NAME: endpointsHitByUseragent
#+BEGIN_SRC json
[
"readFoo": [ "get"],
"readBar": ["get", "watch"]
]
#+END_SRC

so this is saying that readFoo[get] was hit by the user-agent but readFoo[watch] was not.  WE know this because watch is absent in the array.

And when we are filteirng we'd filter all the way down to the method, as the concern is whether they're conformance or not....so we'd want to say"

- if useragent filter is set...
- then return endpoint.filtered where the opId is in "endpointsHitByUseragent"
- then, remove any methods within the endpoint that are not within the array of endointsHitByUseragent[endpoint]

Is there a simpler way for this?  it's a filter, then a prune essentially....If that method worked, we could use the same method for tests too and any other section.




* Tasks
** DONE setup basic dev environment
   CLOSED: [2019-04-08 Mon 09:28]
   this would need to be its own react app, in its own folder that we could point to, so it has its own package.json....otherwise the scripts we run would be for client and not app.
   #+NAME: Create React App for new app
   #+BEGIN_SRC shell :dir ./
  npx create-react-app app
   #+END_SRC

   #+NAME: Explore Files in app
   #+BEGIN_SRC shell :dir ./app/ :results output
  tree -I "node_modules"
   #+END_SRC

   #+RESULTS: Explore Files in app
   #+begin_example
   .
   ├── package.json
   ├── package-lock.json
   ├── public
   │   ├── favicon.ico
   │   ├── index.html
   │   └── manifest.json
   ├── README.md
   └── src
       ├── App.css
       ├── App.js
       ├── App.test.js
       ├── index.css
       ├── index.js
       ├── logo.svg
       └── serviceWorker.js

   2 directories, 13 files
   #+end_example
** DONE [5/5] Port over Code from client.org to get basic site
   CLOSED: [2019-04-08 Mon 10:30]
   - [X] header
   - [X] footer
   - [X] pngs
   - [X] tachyons css
   - [X] it says "HELLO YOU ARE DOING GOOD!"
** DONE [4/4] Display Job Results Metadata at top of header
   CLOSED: [2019-04-08 Mon 12:14]
   - [X]  Define  JobResultsMetadata
   - [X] Create Data Folder and put sample of job results metadata into that
   - [X] Create bundle that loads the job results into state
   - [X] Create component that grabs from that store
** DONE [3/3]Display Endpoint Bundle With Success
   CLOSED: [2019-04-10 Wed 08:54]
   - [X] understand the data that the current endpoint resource needs.
   - [X] Make up data definition for endpoint as it is now
   - [X] change the wording if needed (operatorId's instead of endpoints?)
** TODO [40%] Display the Sunburst
*** DONE Setup Sunburst Bundle in app.org
    CLOSED: [2019-04-10 Wed 12:07]
*** DONE Endpoints Sorted to sunburst following new structure
    CLOSED: [2019-04-10 Wed 12:07]
*** TODO Sunburst Component Added Back in to site, without mouseover yet.
*** TODO Needs for mouseover added to these tasks
*** TODO full sunburst functional again on site.
** TODO Create Test Resources for each of our paths
   These ared static json's that should not change and should be made up of let's say 20 of each.
   There should be a consistent percentage too, if possible.
   So there should be 20 endpoints
   And there should be 20 tests, where 10 endoints are hit by the test included, and 5 of them are hit by the conformance tests included
   There should be 20 useragents, with the results that 10 endpoints are hit by a selected useragent
   There should be 20 test tags, where 10 endpoints are hit by one of the test tags

   It doesn't need to be this exact necessarily, but we want ot make sure that if we apply a filter based on a regex of tests, for example, we know the result we should recive and it is greater than 0
** TODO Create tests for existing bundles, using our test data
** TODO Bring up issue of grouping by kind
the "" as a kind within each category, and sometimes their only kind
** TODO re-tangle backend.org to bring back correct index.js
